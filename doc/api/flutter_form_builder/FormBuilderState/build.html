<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="API docs for the build method from the FormBuilderState class, for the Dart programming language.">
  <title>build method - FormBuilderState class - flutter_form_builder library - Dart API</title>
  <!-- required because all the links are pseudo-absolute -->
  <base href="../..">

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500,400i,400,300|Source+Sans+Pro:400,300,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="static-assets/github.css">
  <link rel="stylesheet" href="static-assets/styles.css">
  <link rel="icon" href="static-assets/favicon.png">
  
</head>

<body>

<div id="overlay-under-drawer"></div>

<header id="title">
  <button id="sidenav-left-toggle" type="button">&nbsp;</button>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="index.html">flutter_form_builder</a></li>
    <li><a href="flutter_form_builder/flutter_form_builder-library.html">flutter_form_builder</a></li>
    <li><a href="flutter_form_builder/FormBuilderState-class.html">FormBuilderState</a></li>
    <li class="self-crumb">build method</li>
  </ol>
  <div class="self-name">build</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<main>

  <div id="dartdoc-sidebar-left" class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left">
    <header id="header-search-sidebar" class="hidden-l">
      <form class="search-sidebar" role="search">
        <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
      </form>
    </header>
    
    <ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
      <li><a href="index.html">flutter_form_builder</a></li>
      <li><a href="flutter_form_builder/flutter_form_builder-library.html">flutter_form_builder</a></li>
      <li><a href="flutter_form_builder/FormBuilderState-class.html">FormBuilderState</a></li>
      <li class="self-crumb">build method</li>
    </ol>
    
    <h5>FormBuilderState class</h5>
    <ol>
      <li class="section-title"><a href="flutter_form_builder/FormBuilderState-class.html#constructors">Constructors</a></li>
      <li><a href="flutter_form_builder/FormBuilderState/FormBuilderState.html">FormBuilderState</a></li>
    
      <li class="section-title">
        <a href="flutter_form_builder/FormBuilderState-class.html#instance-properties">Properties</a>
      </li>
      <li><a href="flutter_form_builder/FormBuilderState/formControls.html">formControls</a></li>
      <li><a href="flutter_form_builder/FormBuilderState/value.html">value</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/context.html">context</a></li>
      <li class="inherited"><a href="dart-core/Object/hashCode.html">hashCode</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/mounted.html">mounted</a></li>
      <li class="inherited"><a href="dart-core/Object/runtimeType.html">runtimeType</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/widget.html">widget</a></li>
    
      <li class="section-title"><a href="flutter_form_builder/FormBuilderState-class.html#instance-methods">Methods</a></li>
      <li><a href="flutter_form_builder/FormBuilderState/build.html">build</a></li>
      <li><a href="flutter_form_builder/FormBuilderState/reset.html">reset</a></li>
      <li><a href="flutter_form_builder/FormBuilderState/save.html">save</a></li>
      <li><a href="flutter_form_builder/FormBuilderState/validate.html">validate</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/deactivate.html">deactivate</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/debugFillProperties.html">debugFillProperties</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/didChangeDependencies.html">didChangeDependencies</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/didUpdateWidget.html">didUpdateWidget</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/dispose.html">dispose</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/initState.html">initState</a></li>
      <li class="inherited"><a href="dart-core/Object/noSuchMethod.html">noSuchMethod</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/reassemble.html">reassemble</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/setState.html">setState</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/toDiagnosticsNode.html">toDiagnosticsNode</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/toString.html">toString</a></li>
      <li class="inherited"><a href="flutter_form_builder/FormBuilderState/toStringShort.html">toStringShort</a></li>
    
      <li class="section-title inherited"><a href="flutter_form_builder/FormBuilderState-class.html#operators">Operators</a></li>
      <li class="inherited"><a href="dart-core/Object/operator_equals.html">operator ==</a></li>
    
    
    
    </ol>
  </div><!--/.sidebar-offcanvas-->

  <div id="dartdoc-main-content" class="col-xs-12 col-sm-9 col-md-8 main-content">
      <div><h1>build method</h1></div>

    <section class="multi-line-signature">
      <div>
        <ol class="annotation-list">
          <li>@override</li>
        </ol>
      </div>
      <span class="returntype">Widget</span>
            <span class="name ">build</span>
(<wbr><span class="parameter" id="build-param-context"><span class="type-annotation">BuildContext</span> <span class="parameter-name">context</span></span>)
      
    </section>
    <section class="desc markdown">
      <p>Describes the part of the user interface represented by this widget.</p>
<p>The framework calls this method in a number of different situations:</p><ul><li>After calling <a href="flutter_form_builder/FormBuilderState/initState.html">initState</a>.</li><li>After calling <a href="flutter_form_builder/FormBuilderState/didUpdateWidget.html">didUpdateWidget</a>.</li><li>After receiving a call to <a href="flutter_form_builder/FormBuilderState/setState.html">setState</a>.</li><li>After a dependency of this <code>State</code> object changes (e.g., an
<code>InheritedWidget</code> referenced by the previous <a href="flutter_form_builder/FormBuilderState/build.html">build</a> changes).</li><li>After calling <a href="flutter_form_builder/FormBuilderState/deactivate.html">deactivate</a> and then reinserting the <code>State</code> object into
the tree at another location.</li></ul>
<p>The framework replaces the subtree below this widget with the widget
returned by this method, either by updating the existing subtree or by
removing the subtree and inflating a new subtree, depending on whether the
widget returned by this method can update the root of the existing
subtree, as determined by calling <code>Widget.canUpdate</code>.</p>
<p>Typically implementations return a newly created constellation of widgets
that are configured with information from this widget's constructor, the
given <code>BuildContext</code>, and the internal state of this <code>State</code> object.</p>
<p>The given <code>BuildContext</code> contains information about the location in the
tree at which this widget is being built. For example, the context
provides the set of inherited widgets for this location in the tree. The
<code>BuildContext</code> argument is always the same as the <code>context</code> property of
this <code>State</code> object and will remain the same for the lifetime of this
object. The <code>BuildContext</code> argument is provided redundantly here so that
this method matches the signature for a <code>WidgetBuilder</code>.</p>
<h2 id="design-discussion">Design discussion</h2>
<h3 id="why-is-the-build-method-on-state-and-not-statefulwidget">Why is the <a href="flutter_form_builder/FormBuilderState/build.html">build</a> method on <code>State</code>, and not <code>StatefulWidget</code>?</h3>
<p>Putting a <code>Widget build(BuildContext context)</code> method on <code>State</code> rather
putting a <code>Widget build(BuildContext context, State state)</code> method on
<code>StatefulWidget</code> gives developers more flexibility when subclassing
<code>StatefulWidget</code>.</p>
<p>For example, <code>AnimatedWidget</code> is a subclass of <code>StatefulWidget</code> that
introduces an abstract <code>Widget build(BuildContext context)</code> method for its
subclasses to implement. If <code>StatefulWidget</code> already had a <a href="flutter_form_builder/FormBuilderState/build.html">build</a> method
that took a <code>State</code> argument, <code>AnimatedWidget</code> would be forced to provide
its <code>State</code> object to subclasses even though its <code>State</code> object is an
internal implementation detail of <code>AnimatedWidget</code>.</p>
<p>Conceptually, <code>StatelessWidget</code> could also be implemented as a subclass of
<code>StatefulWidget</code> in a similar manner. If the <a href="flutter_form_builder/FormBuilderState/build.html">build</a> method were on
<code>StatefulWidget</code> rather than <code>State</code>, that would not be possible anymore.</p>
<p>Putting the <a href="flutter_form_builder/FormBuilderState/build.html">build</a> function on <code>State</code> rather than <code>StatefulWidget</code> also
helps avoid a category of bugs related to closures implicitly capturing
<code>this</code>. If you defined a closure in a <a href="flutter_form_builder/FormBuilderState/build.html">build</a> function on a
<code>StatefulWidget</code>, that closure would implicitly capture <code>this</code>, which is
the current widget instance, and would have the (immutable) fields of that
instance in scope:</p>
<pre class="language-dart"><code class="language-dart">class MyButton extends StatefulWidget {
  ...
  final Color color;

  @override
  Widget build(BuildContext context, MyButtonState state) {
    ... () { print("color: $color"); } ...
  }
}
</code></pre>
<p>For example, suppose the parent builds <code>MyButton</code> with <code>color</code> being blue,
the <code>$color</code> in the print function refers to blue, as expected. Now,
suppose the parent rebuilds <code>MyButton</code> with green. The closure created by
the first build still implicitly refers to the original widget and the
<code>$color</code> still prints blue even through the widget has been updated to
green.</p>
<p>In contrast, with the <a href="flutter_form_builder/FormBuilderState/build.html">build</a> function on the <code>State</code> object, closures
created during <a href="flutter_form_builder/FormBuilderState/build.html">build</a> implicitly capture the <code>State</code> instance instead of
the widget instance:</p>
<pre class="language-dart"><code class="language-dart">class MyButtonState extends State&lt;MyButton&gt; {
  ...
  @override
  Widget build(BuildContext context) {
    ... () { print("color: ${widget.color}"); } ...
  }
}
</code></pre>
<p>Now when the parent rebuilds <code>MyButton</code> with green, the closure created by
the first build still refers to <code>State</code> object, which is preserved across
rebuilds, but the framework has updated that <code>State</code> object's <a href="flutter_form_builder/FormBuilderState/widget.html">widget</a>
property to refer to the new <code>MyButton</code> instance and <code>${widget.color}</code>
prints green, as expected.</p>
<p>See also:</p><ul><li><code>StatefulWidget</code>, which contains the discussion on performance considerations.</li></ul>
    </section>
    
    <section class="summary source-code" id="source">
      <h2><span>Implementation</span></h2>
      <pre class="language-dart"><code class="language-dart">@override
Widget build(BuildContext context) {
  return Form(
    key: _formKey,
    &#47;&#47;TODO: Allow user to update field value or validate based on changes in others (e.g. Summations, Confirm Password)
    onChanged: () {
      if (widget.onChanged != null) {
        _formKey.currentState.save();
        widget.onChanged(value);
      }
    },
    onWillPop: widget.onWillPop,
    autovalidate: widget.autovalidate,
    child: Column(
      children: this.formControls.map((FormBuilderInput formControl) {
        &#47;&#47; GlobalKey&lt;FormFieldState&gt; _fieldKey = GlobalKey(debugLabel: formControl.attribute);
        &#47;&#47; _fieldKeys[formControl.attribute] = _fieldKey;
        if (formControl != null) {
          switch (formControl.type) {
            case FormBuilderInput.TYPE_TEXT:
            case FormBuilderInput.TYPE_PASSWORD:
            case FormBuilderInput.TYPE_NUMBER:
            case FormBuilderInput.TYPE_PHONE:
            case FormBuilderInput.TYPE_EMAIL:
            case FormBuilderInput.TYPE_URL:
            case FormBuilderInput.TYPE_MULTILINE_TEXT:
              TextInputType keyboardType;
              switch (formControl.type) {
                case FormBuilderInput.TYPE_NUMBER:
                  keyboardType = TextInputType.number;
                  break;
                case FormBuilderInput.TYPE_EMAIL:
                  keyboardType = TextInputType.emailAddress;
                  break;
                case FormBuilderInput.TYPE_URL:
                  keyboardType = TextInputType.url;
                  break;
                case FormBuilderInput.TYPE_PHONE:
                  keyboardType = TextInputType.phone;
                  break;
                case FormBuilderInput.TYPE_MULTILINE_TEXT:
                  keyboardType = TextInputType.multiline;
                  break;
                default:
                  keyboardType = TextInputType.text;
                  break;
              }
              return TextFormField(
                &#47;&#47; &#47;&#47; key: _fieldKey,
                enabled: !(widget.readonly || formControl.readonly),
                style: (widget.readonly || formControl.readonly)
                    ? Theme.of(context).textTheme.subhead.copyWith(
                          color: Theme.of(context).disabledColor,
                        )
                    : null,
                focusNode: (widget.readonly || formControl.readonly)
                    ? AlwaysDisabledFocusNode()
                    : null,
                decoration: formControl.decoration.copyWith(
                  enabled: !(widget.readonly || formControl.readonly),
                ),
                autovalidate: formControl.autovalidate ?? false,
                initialValue:
                    formControl.value != null ? &quot;${formControl.value}&quot; : &#39;&#39;,
                maxLines:
                    formControl.type == FormBuilderInput.TYPE_MULTILINE_TEXT
                        ? formControl.maxLines
                        : 1,
                keyboardType: keyboardType,
                obscureText:
                    formControl.type == FormBuilderInput.TYPE_PASSWORD
                        ? true
                        : false,
                onSaved: (val) {
                  value[formControl.attribute] =
                      formControl.type == FormBuilderInput.TYPE_NUMBER
                          ? num.tryParse(val)
                          : val;
                },
                onFieldSubmitted: (data) {
                  if (formControl.onChanged != null)
                    formControl.onChanged(data);
                },
                validator: (val) {
                  if (formControl.require &amp;&amp; val.isEmpty)
                    return &quot;${formControl.attribute} is required&quot;;

                  if (formControl.type == FormBuilderInput.TYPE_NUMBER) {
                    if (num.tryParse(val) == null &amp;&amp; val.isNotEmpty)
                      return &quot;$val is not a valid number&quot;;
                    if (formControl.max != null &amp;&amp;
                        num.tryParse(val) &gt; formControl.max)
                      return &quot;${formControl.attribute} should not be greater than ${formControl.max}&quot;;
                    if (formControl.min != null &amp;&amp;
                        num.tryParse(val) &lt; formControl.min)
                      return &quot;${formControl.attribute} should not be less than ${formControl.min}&quot;;
                  } else {
                    if (formControl.max != null &amp;&amp;
                        val.length &gt; formControl.max)
                      return &quot;${formControl.attribute} should have ${formControl.max} character(s) or less&quot;;
                    if (formControl.min != null &amp;&amp;
                        val.length &lt; formControl.min)
                      return &quot;${formControl.attribute} should have ${formControl.min} character(s) or more&quot;;
                  }

                  if (formControl.type == FormBuilderInput.TYPE_EMAIL &amp;&amp;
                      val.isNotEmpty) {
                    Pattern pattern =
                        r&#39;^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$&#39;;
                    if (!RegExp(pattern).hasMatch(val))
                      return &#39;$val is not a valid email address&#39;;
                  }

                  if (formControl.type == FormBuilderInput.TYPE_URL &amp;&amp;
                      val.isNotEmpty) {
                    Pattern pattern =
                        r&quot;(https?|ftp):&#47;&#47;([-A-Z0-9.]+)(&#47;[-A-Z0-9+&amp;@#&#47;%=~_|!:,.;]*)?(\?[A-Z0-9+&amp;@#&#47;%=~_|!:‌​,.;]*)?&quot;;
                    if (!RegExp(pattern, caseSensitive: false).hasMatch(val))
                      return &#39;$val is not a valid URL&#39;;
                  }

                  if (formControl.validator != null)
                    return formControl.validator(val);
                },
                &#47;&#47; autovalidate: ,
              );
              break;

            case FormBuilderInput.TYPE_DATE_TIME_PICKER:
              return DateTimePickerFormField(
                &#47;&#47; key: _fieldKey,
                inputType: InputType.both,
                initialValue: formControl.value,
                format: formControl.format != null
                    ? DateFormat(formControl.format)
                    : _dateTimeFormats[InputType.both],
                enabled: !(formControl.readonly || widget.readonly),
                firstDate: formControl.firstDate,
                lastDate: formControl.lastDate,
                decoration: formControl.decoration.copyWith(
                  enabled: !(widget.readonly || formControl.readonly),
                ),
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                validator: (val) {
                  if (formControl.require &amp;&amp; val == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(val);
                },
              );
              break;

            case FormBuilderInput.TYPE_DATE_PICKER:
              return DateTimePickerFormField(
                &#47;&#47; key: _fieldKey,
                inputType: InputType.date,
                initialValue: formControl.value,
                format: formControl.format != null
                    ? DateFormat(formControl.format)
                    : _dateTimeFormats[InputType.date],
                enabled: !(formControl.readonly || widget.readonly),
                firstDate: formControl.firstDate,
                lastDate: formControl.lastDate,
                decoration: formControl.decoration.copyWith(
                  enabled: !(widget.readonly || formControl.readonly),
                ),
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                validator: (val) {
                  if (formControl.require &amp;&amp; val == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(val);
                },
              );
              break;

            case FormBuilderInput.TYPE_TIME_PICKER:
              return DateTimePickerFormField(
                &#47;&#47; key: _fieldKey,
                inputType: InputType.time,
                initialValue: formControl.value,
                format: formControl.format != null
                    ? DateFormat(formControl.format)
                    : _dateTimeFormats[InputType.time],
                enabled: !(formControl.readonly || widget.readonly),
                decoration: formControl.decoration.copyWith(
                  enabled: !(widget.readonly || formControl.readonly),
                ),
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                validator: (val) {
                  if (formControl.require &amp;&amp; val == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(val);
                },
              );
              break;

            case FormBuilderInput.TYPE_TYPE_AHEAD:
              TextEditingController _typeAheadController =
                  TextEditingController(text: formControl.value);
              return TypeAheadFormField(
                &#47;&#47; key: _fieldKey,
                textFieldConfiguration: TextFieldConfiguration(
                  enabled: !(widget.readonly || formControl.readonly),
                  controller: _typeAheadController,
                  style: (widget.readonly || formControl.readonly)
                      ? Theme.of(context).textTheme.subhead.copyWith(
                            color: Theme.of(context).disabledColor,
                          )
                      : null,
                  focusNode: (widget.readonly || formControl.readonly)
                      ? AlwaysDisabledFocusNode()
                      : null,
                  decoration: formControl.decoration.copyWith(
                    enabled: !(widget.readonly || formControl.readonly),
                  ),
                ),
                suggestionsCallback: formControl.suggestionsCallback,
                itemBuilder: formControl.itemBuilder,
                transitionBuilder: (context, suggestionsBox, controller) =&gt;
                    suggestionsBox,
                onSuggestionSelected: (suggestion) {
                  _typeAheadController.text = suggestion;
                },
                validator: (val) {
                  if (formControl.require &amp;&amp; val.isEmpty)
                    return &#39;${formControl.attribute} is required&#39;;

                  if (formControl.validator != null)
                    return formControl.validator(val);
                },
                onSaved: (val) =&gt; value[formControl.attribute] = val,
                getImmediateSuggestions: formControl.getImmediateSuggestions,
                errorBuilder: formControl.errorBuilder,
                noItemsFoundBuilder: formControl.noItemsFoundBuilder,
                loadingBuilder: formControl.loadingBuilder,
                debounceDuration: formControl.debounceDuration,
                suggestionsBoxDecoration:
                    formControl.suggestionsBoxDecoration,
                suggestionsBoxVerticalOffset:
                    formControl.suggestionsBoxVerticalOffset,
                &#47;&#47; transitionBuilder: formControl.transitionBuilder,
                animationDuration: formControl.animationDuration,
                animationStart: formControl.animationStart,
                direction: formControl.direction,
                hideOnLoading: formControl.hideOnLoading,
                hideOnEmpty: formControl.hideOnEmpty,
                hideOnError: formControl.hideOnError,
                hideSuggestionsOnKeyboardHide:
                    formControl.hideSuggestionsOnKeyboardHide,
                keepSuggestionsOnLoading:
                    formControl.keepSuggestionsOnLoading,
                autoFlipDirection: formControl.autoFlipDirection,
                autovalidate:
                    (formControl.autovalidate || widget.autovalidate),
              );
              break;

            case FormBuilderInput.TYPE_DROPDOWN:
              return FormField(
                &#47;&#47; key: _fieldKey,
                enabled: !(widget.readonly || formControl.readonly),
                initialValue: formControl.value,
                validator: (val) {
                  if (formControl.require &amp;&amp; val == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(val);
                },
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                      contentPadding: EdgeInsets.only(top: 10.0, bottom: 0.0),
                      border: InputBorder.none,
                    ),
                    child: DropdownButton(
                      isExpanded: true,
                      &#47;&#47; hint: Text(formControl.hint ?? &#39;&#39;), &#47;&#47;TODO: Dropdown may require hint
                      items: formControl.options.map((option) {
                        return DropdownMenuItem(
                          child: Text(&quot;${option.label ?? option.value}&quot;),
                          value: option.value,
                        );
                      }).toList(),
                      value: field.value,
                      onChanged: (widget.readonly || formControl.readonly)
                          ? null
                          : (value) {
                              field.didChange(value);
                            },
                    ),
                  );
                },
              );
              break;

            &#47;&#47;TODO: For TYPE_CHECKBOX, TYPE_CHECKBOX_LIST, TYPE_RADIO allow user to choose if checkbox&#47;radio to appear before or after Label
            case FormBuilderInput.TYPE_RADIO:
              return FormField(
                &#47;&#47; key: _fieldKey,
                enabled: !widget.readonly &amp;&amp; !formControl.readonly,
                initialValue: formControl.value,
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                validator: (value) {
                  if (formControl.require &amp;&amp; value == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(value);
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  List&lt;Widget&gt; radioList = [];
                  for (int i = 0; i &lt; formControl.options.length; i++) {
                    radioList.addAll([
                      ListTile(
                        dense: true,
                        isThreeLine: false,
                        contentPadding: EdgeInsets.all(0.0),
                        leading: null,
                        title: Text(
                            &quot;${formControl.options[i].label ?? formControl.options[i].value}&quot;),
                        trailing: Radio&lt;dynamic&gt;(
                          value: formControl.options[i].value,
                          groupValue: field.value,
                          onChanged: (widget.readonly || formControl.readonly)
                              ? null
                              : (dynamic value) {
                                  field.didChange(value);
                                },
                        ),
                        onTap: (widget.readonly || formControl.readonly)
                            ? null
                            : () {
                                field.didChange(formControl.options[i].value);
                              },
                      ),
                      Divider(
                        height: 0.0,
                      ),
                    ]);
                  }
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                      contentPadding: EdgeInsets.only(top: 10.0, bottom: 0.0),
                      border: InputBorder.none,
                    ),
                    child: Column(
                      children: radioList,
                    ),
                  );
                },
              );
              break;

            case FormBuilderInput.TYPE_SEGMENTED_CONTROL:
              return FormField(
                &#47;&#47; key: _fieldKey,
                initialValue: formControl.value,
                enabled: !(widget.readonly || formControl.readonly),
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                validator: (value) {
                  if (formControl.require &amp;&amp; value == null)
                    return &quot;${formControl.require} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(value);
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                      contentPadding:
                          EdgeInsets.only(top: 10.0, bottom: 10.0),
                      border: InputBorder.none,
                    ),
                    child: Padding(
                      padding: EdgeInsets.only(top: 10.0),
                      child: CupertinoSegmentedControl(
                        borderColor: (widget.readonly || formControl.readonly)
                            ? Theme.of(context).disabledColor
                            : Theme.of(context).primaryColor,
                        selectedColor:
                            (widget.readonly || formControl.readonly)
                                ? Theme.of(context).disabledColor
                                : Theme.of(context).primaryColor,
                        pressedColor:
                            (widget.readonly || formControl.readonly)
                                ? Theme.of(context).disabledColor
                                : Theme.of(context).primaryColor,
                        groupValue: field.value,
                        children: Map.fromIterable(
                          formControl.options,
                          key: (v) =&gt; v.value,
                          value: (v) =&gt; Padding(
                                padding: EdgeInsets.symmetric(vertical: 10.0),
                                child: Text(&quot;${v.label ?? v.value}&quot;),
                              ),
                        ),
                        onValueChanged: (dynamic value) {
                          if (widget.readonly || formControl.readonly) {
                            field.reset();
                          } else
                            field.didChange(value);
                        },
                      ),
                    ),
                  );
                },
              );
              break;

            case FormBuilderInput.TYPE_SWITCH:
              return FormField(
                  &#47;&#47; key: _fieldKey,
                  enabled: !(widget.readonly || formControl.readonly),
                  initialValue: formControl.value ?? false,
                  validator: (value) {
                    if (formControl.require &amp;&amp; value == null)
                      return &quot;${formControl.attribute} is required&quot;;
                    &#47;*if (formControl.validator != null)
                  return formControl.validator(value);*&#47;
                  },
                  onSaved: (val) {
                    value[formControl.attribute] = val;
                  },
                  builder: (FormFieldState&lt;dynamic&gt; field) {
                    return InputDecorator(
                      decoration: formControl.decoration.copyWith(
                        enabled: !(widget.readonly || formControl.readonly),
                        errorText: field.errorText,
                      ),
                      child: ListTile(
                        dense: true,
                        isThreeLine: false,
                        contentPadding: EdgeInsets.all(0.0),
                        title: formControl.label,
                        trailing: Switch(
                          value: field.value,
                          onChanged: (widget.readonly || formControl.readonly)
                              ? null
                              : (bool value) {
                                  field.didChange(value);
                                },
                        ),
                        onTap: (widget.readonly || formControl.readonly)
                            ? null
                            : () {
                                bool newValue = !(field.value ?? false);
                                field.didChange(newValue);
                              },
                      ),
                    );
                  });
              break;

            case FormBuilderInput.TYPE_STEPPER:
              return FormField(
                enabled: !(widget.readonly || formControl.readonly),
                &#47;&#47; key: _fieldKey,
                initialValue: formControl.value,
                validator: (value) {
                  if (formControl.require &amp;&amp; value == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(value);
                },
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                    ),
                    child: SyStepper(
                      value: field.value ?? 0,
                      step: formControl.step ?? 1,
                      min: formControl.min ?? 0,
                      max: formControl.max ?? 9999999,
                      size: 24.0,
                      onChange: (widget.readonly || formControl.readonly)
                          ? null
                          : (value) {
                              field.didChange(value);
                            },
                    ),
                  );
                },
              );
              break;

            case FormBuilderInput.TYPE_RATE:
              return FormField(
                enabled: !(widget.readonly || formControl.readonly),
                &#47;&#47; key: _fieldKey,
                initialValue: formControl.value ?? 1,
                validator: (value) {
                  if (formControl.require &amp;&amp; value == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(value);
                },
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                    ),
                    child: SyRate(
                      value: field.value,
                      total: formControl.max,
                      icon: formControl.icon,
                      &#47;&#47;TODO: When disabled change icon color (Probably deep grey)
                      iconSize: formControl.iconSize ?? 24.0,
                      onTap: (widget.readonly || formControl.readonly)
                          ? null
                          : (value) {
                              field.didChange(value);
                            },
                    ),
                  );
                },
              );
              break;

            case FormBuilderInput.TYPE_CHECKBOX:
              return FormField(
                &#47;&#47; key: _fieldKey,
                enabled: !(widget.readonly || formControl.readonly),
                initialValue: formControl.value ?? false,
                validator: (value) {
                  if (formControl.require &amp;&amp; value == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(value);
                },
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                    ),
                    child: ListTile(
                      dense: true,
                      isThreeLine: false,
                      contentPadding: EdgeInsets.all(0.0),
                      title: formControl.label,
                      trailing: Checkbox(
                        value: field.value ?? false,
                        onChanged: (widget.readonly || formControl.readonly)
                            ? null
                            : (bool value) {
                                field.didChange(value);
                              },
                      ),
                      onTap: (widget.readonly || formControl.readonly)
                          ? null
                          : () {
                              bool newValue = !(field.value ?? false);
                              field.didChange(newValue);
                            },
                    ),
                  );
                },
              );
              break;

            case FormBuilderInput.TYPE_SLIDER:
              return FormField(
                &#47;&#47; key: _fieldKey,
                enabled: !(widget.readonly || formControl.readonly),
                initialValue: formControl.value,
                validator: (value) {
                  if (formControl.require &amp;&amp; value == null)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(value);
                },
                onSaved: (val) {
                  value[formControl.attribute] = val;
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                    ),
                    child: Container(
                      padding: EdgeInsets.only(top: 10.0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Slider(
                            value: field.value,
                            min: formControl.min,
                            max: formControl.max,
                            divisions: formControl.divisions,
                            onChanged:
                                (widget.readonly || formControl.readonly)
                                    ? null
                                    : (double value) {
                                        field.didChange(value);
                                      },
                          ),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: &lt;Widget&gt;[
                              Text(&quot;${formControl.min}&quot;),
                              Text(&quot;${field.value}&quot;),
                              Text(&quot;${formControl.max}&quot;),
                            ],
                          ),
                        ],
                      ),
                    ),
                  );
                },
              );
              break;

            case FormBuilderInput.TYPE_CHECKBOX_LIST:
              return FormField(
                  &#47;&#47; key: _fieldKey,
                  enabled: !(widget.readonly || formControl.readonly),
                  initialValue: formControl.value ?? [],
                  onSaved: (val) {
                    value[formControl.attribute] = val;
                  },
                  validator: formControl.validator,
                  builder: (FormFieldState&lt;dynamic&gt; field) {
                    List&lt;Widget&gt; checkboxList = [];
                    for (int i = 0; i &lt; formControl.options.length; i++) {
                      checkboxList.addAll([
                        ListTile(
                          dense: true,
                          isThreeLine: false,
                          contentPadding: EdgeInsets.all(0.0),
                          leading: Checkbox(
                            value: field.value
                                .contains(formControl.options[i].value),
                            onChanged: (widget.readonly ||
                                    formControl.readonly)
                                ? null
                                : (bool value) {
                                    var currValue = field.value;
                                    if (value)
                                      currValue
                                          .add(formControl.options[i].value);
                                    else
                                      currValue.remove(
                                          formControl.options[i].value);
                                    field.didChange(currValue);
                                  },
                          ),
                          title: Text(
                              &quot;${formControl.options[i].label ?? formControl.options[i].value}&quot;),
                          onTap: (widget.readonly || formControl.readonly)
                              ? null
                              : () {
                                  var currentValue = field.value;
                                  if (!currentValue
                                      .contains(formControl.options[i].value))
                                    currentValue
                                        .add(formControl.options[i].value);
                                  else
                                    currentValue
                                        .remove(formControl.options[i].value);
                                  field.didChange(currentValue);
                                },
                        ),
                        Divider(
                          height: 0.0,
                        ),
                      ]);
                    }
                    return InputDecorator(
                      decoration: formControl.decoration.copyWith(
                        enabled: !(widget.readonly || formControl.readonly),
                        errorText: field.errorText,
                        contentPadding:
                            EdgeInsets.only(top: 10.0, bottom: 0.0),
                        border: InputBorder.none,
                      ),
                      child: Column(
                        children: checkboxList,
                      ),
                    );
                  });
              break;
            case FormBuilderInput.TYPE_CHIPS_INPUT:
              return SizedBox(
                &#47;&#47; height: 200.0,
                child: FormField(
                  &#47;&#47; key: _fieldKey,
                  enabled: !(widget.readonly || formControl.readonly),
                  initialValue: formControl.value ?? [],
                  onSaved: (val) {
                    value[formControl.attribute] = val;
                  },
                  validator: (value) {
                    if (formControl.require &amp;&amp; value.length == 0)
                      return &quot;${formControl.attribute} is required&quot;;
                    if (formControl.validator != null)
                      return formControl.validator(value);
                  },
                  builder: (FormFieldState&lt;dynamic&gt; field) {
                    return ChipsInput(
                      initialValue: field.value,
                      enabled: !(widget.readonly || formControl.readonly),
                      decoration: formControl.decoration.copyWith(
                        enabled: !(widget.readonly || formControl.readonly),
                        errorText: field.errorText,
                      ),
                      findSuggestions: formControl.suggestionsCallback,
                      onChanged: (data) {
                        field.didChange(data);
                      },
                      maxChips: formControl.max,
                      chipBuilder: formControl.chipBuilder,
                      suggestionBuilder: formControl.suggestionBuilder,
                    );
                  },
                ),
              );
              break;

            case FormBuilderInput.TYPE_SIGNATURE_PAD:
              var _signatureCanvas = Signature(
                points: formControl.points,
                width: formControl.width,
                height: formControl.height,
                backgroundColor: formControl.backgroundColor,
                penColor: formControl.penColor,
                penStrokeWidth: formControl.penStrokeWidth,
              );

              return FormField&lt;Image&gt;(
                key: Key(formControl.attribute),
                enabled: !(widget.readonly || formControl.readonly),
                initialValue: formControl.value,
                onSaved: (val) async {
                  Uint8List signature = await _signatureCanvas.exportBytes();
                  var image = Image.memory(signature).image;
                  value[formControl.attribute] = image;
                },
                validator: (value) {
                  if (formControl.require &amp;&amp; _signatureCanvas.isEmpty)
                    return &quot;${formControl.attribute} is required&quot;;
                  if (formControl.validator != null)
                    return formControl.validator(value);
                },
                builder: (FormFieldState&lt;dynamic&gt; field) {
                  return InputDecorator(
                    decoration: formControl.decoration.copyWith(
                      enabled: !(widget.readonly || formControl.readonly),
                      errorText: field.errorText,
                    ),
                    child: Column(
                      children: &lt;Widget&gt;[
                        Container(
                          decoration: BoxDecoration(
                            border: Border.all(color: Colors.grey),
                          ),
                          child: GestureDetector(
                            onVerticalDragUpdate: (_) {},
                            child: _signatureCanvas,
                          ),
                        ),
                        Row(
                          children: &lt;Widget&gt;[
                            Expanded(child: SizedBox()),
                            FlatButton(
                                onPressed: () {
                                  _signatureCanvas.clear();
                                  field.didChange(null);
                                },
                                child: Text(&#39;Clear&#39;)),
                          ],
                        ),
                      ],
                    ),
                  );
                },
              );
              break;
          }
        } else
          return Container();
      }).toList(),
    ),
  );
}</code></pre>
    </section>

  </div> <!-- /.main-content -->

  <div id="dartdoc-sidebar-right" class="col-xs-6 col-sm-6 col-md-2 sidebar sidebar-offcanvas-right">
  </div><!--/.sidebar-offcanvas-->

</main>

<footer>
  <span class="no-break">
    flutter_form_builder 2.1.0
  </span>

  
</footer>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="static-assets/typeahead.bundle.min.js"></script>
<script src="static-assets/highlight.pack.js"></script>
<script src="static-assets/URI.js"></script>
<script src="static-assets/script.js"></script>


</body>

</html>
